<style>
	@font-face {
		font-family: mc;
		src: url('../font.ttf') format('truetype');
		font-weight: normal;
		font-style: normal;
	}
</style>
<script>
	document.fonts.forEach(font => font.load())
	onmessage = ({data}) => msgQueue.push(data)
	const postMessage = parent.postMessage.bind(parent)
	let msgQueue = []
	parent.postMessage(null, '*')
	const _filecache = Object.create(null)
	const _c = document.createElement('canvas')
	const _texture = class Texture{
		constructor(img, x, y, w, h){ this.img = img; this.x = x; this.y = y; this.w = w; this.h = h; this._pattern = null }
		crop(x, y, w, h){ return new _texture(this.img, this.x + x, this.y + y, w, h) }
		at(x, y){ return new _texture(this.img, this.x + x * TEX_SIZE, this.y + y * TEX_SIZE, TEX_SIZE, TEX_SIZE) }
		pattern(rep = ''){
			if(this._pattern)return this._pattern
			const c = document.createElement('canvas')
			const ctx = c.getContext('2d')
			if(this.img.complete === false){
				this.img.addEventListener('load', () => {
					c.width = this.w; c.height = this.h
					ctx.drawImage(this.img, this.x, this.y, this.w, this.h, 0, 0, this.w, this.h)
					this._pattern = ctx.createPattern(c, rep)
				})
			}else{
				c.width = this.w; c.height = this.h
				ctx.drawImage(this.img, this.x, this.y, this.w, this.h, 0, 0, this.w, this.h)
				this._pattern = ctx.createPattern(c, rep)
			}
			return this
		}
	}
	const Texture = src => {
		if(_filecache[src])return _filecache[src]
		const i = new Image()
		i.crossOrigin = 'anonymous'
		i.src = src
		loading++
		const t = new _texture(i, 0, 0, 0, 0)
		i.onload = i.onerror = () => (i.onload=i.onerror=null,t.w=i.width,t.h=i.height,--loading||loaded())
		return t
	}
	let _i = 0, _soundEndedCbs = new Map
	const Audio = (src, bg = false) => {
		const aid = _i++
		postMessage([aid, src, bg], '*')
		return (vol = 1, pitch = 1, pan = 0, start = 0, end = NaN, ends = true) => {
			const sid = _i++
			postMessage([aid, sid, start, end, !ends, vol, pitch, pan], '*')
			if(typeof ends == 'function')_soundEndedCbs.set(sid, ends)
			return () => postMessage([aid, sid], '*')
		}
	}
	const TEX_SIZE = 16
	CanvasRenderingContext2D.prototype.texture = function(x, y, w = this.width, h = this.height){
		return new _texture(this.canvas, x, y, w, h)
	}
	;(C => {
		/**
		 * Note on performance
		 * ctx.scale(x, y) seems to be closely tied to the immediate draw action
		 * It's really hard to determine whether this has a positive or negative performance impact
		 * By all logical standards it should worsen performance, but results are really incosistent across:
		 * - Browser
		 * - Whether it's a scaled draw
		 * - CPU or GPU
		 * - current transformation matrix
		 * 
		 * Additionally, despite docs saying otherwise, specifying a newgative sourceHeight in drawImage does not, in fact, flip the image
		 * which would have most likely allowed an improve in performane if it did
		 * This is actually the primary concern here (text isn't a cheap operation to begin with and it's not drawn in large quantities, but images are)
		 * 
		 * Any insight by someone who has more knowledge of the workings of Canvas API in v8, tracemonkey or applewebkit would be greatly appreciated
		 * 
		 * 
		 * An alternative solution that I may implement later is to modify the transformation matrix,
		 * and coordinates be adjusted individually for each operation (including .rect(), .circle(), ...)
		 */
		const _fillTxt = C.fillText, _strokeTxt = C.strokeText, {set: setFillStyle, get: getFillStyle} = Object.getOwnPropertyDescriptor(C, 'fillStyle'),{set: setStrokeStyle, get: getStrokeStyle} = Object.getOwnPropertyDescriptor(C, 'strokeStyle')
		C.setFillStyle = setFillStyle; C.getFillStyle = getFillStyle
		C.setStrokeStyle = setStrokeStyle; C.getStrokeStyle = getStrokeStyle
		C.fillText = function(t, x, y, s, maxW = 2147483647){
			s *= .001
			const S = 1/s
			this.scale(s, -s)
			_fillTxt.call(this, t, x*S, -y*S, maxW*S)
			this.scale(S,-S)
		}
		C.strokeText = function(t, x, y, s, maxW = Infinity){
			s *= .001
			const S = 1/s
			this.scale(s, -s)
			_strokeTxt.call(this, t, x*S, -y*S, maxW*S)
			this.scale(S,-S)
		}
		//Canvas API sucks
		C.image = function(img, x, y, w = img.w, h = img.h, ix = 0, iy = 0, ow = img.w, oh = img.h){
			if(w > 0){
				if(h < 0){
					this.drawImage(img.img, img.x + ix, img.y + iy, ow, oh, x, y, w, h)
				}else{
					this.scale(1,-1)
					this.drawImage(img.img, img.x + ix, img.y + iy, ow, oh, x, -y, w, -h)
					this.scale(1,-1)
				}
			}else if(h < 0){
				this.scale(-1,1)
				this.drawImage(img.img, img.x + ix, img.y + iy, ow, oh, -x, y, -w, h)
				this.scale(-1,1)
			}else{
				this.scale(-1,-1)
				this.drawImage(img.img, img.x + ix, img.y + iy, ow, oh, -x, -y, -w, -h)
				this.scale(-1,-1)
			}
		}
		C.measure = function(txt){
			const {actualBoundingBoxLeft: left, actualBoundingBoxRight: right, actualBoundingBoxAscent: top, actualBoundingBoxDescent: bottom, width} = this.measureText(txt)
			return {left: left / 1000, right: right / 1000, top: top / 1000, bottom: bottom / 1000, width: width / 1000}
		}
		C.push = function(){
			//V8 says we can avoid allocation because the object does not escape. We extract props and add them directly to the array, avoiding the super expensive DOMMatrix object allocation. If you try and touch the following line, you better be sleeping with one eye open...
			const {a, b, c, d, e, f} = this.getTransform()
			this.transforms.push(f, e, d, c, b, a)
		}
		C.pop = function(){
			this.setTransform(this.transforms.pop(), this.transforms.pop(), this.transforms.pop(), this.transforms.pop(), this.transforms.pop(), this.transforms.pop())
		}
		C.peek = function(){
			const l = this.transforms.length
			this.setTransform(this.transforms[l-1], this.transforms[l-2], this.transforms[l-3], this.transforms[l-4], this.transforms[l-5], this.transforms[l-6])
		}
		C.mouse = function(){
			const {a, b, c, d, e, f} = this.getTransform()
			const det = a * d - b * c
			// x y 1
			// a c e -> x
			// b d f -> y
			return {
				x: mx * d / det - mx * c / det + (c * f - d * e) / det,
				y: my * a / det - my * b / det + (b * e - a * f) / det
			}
		}
		Object.defineProperty(C, 'fillStyle', {get: getFillStyle, set(a){this.setFillStyle(a._pattern||a)}})
		Object.defineProperty(C, 'strokeStyle', {get: getStrokeStyle, set(a){this.setStrokeStyle(a._pattern||a)}})
	})(CanvasRenderingContext2D.prototype)
	Math.fclamp = (a, b = 1) => a < 0 ? 0 : (a > b ? b : a)
	Math.ifloat = x => {
		let f = Math.floor(x)
		return (f >> 0) + (x - f)
	}
	for(const n of [HTMLCollection, NodeList])Object.setPrototypeOf(n.prototype, Array.prototype)
	Object.defineProperties(Array.prototype, {
		winner: {enumerable: false, value(pred){
			let best = -Infinity
			let winner = null
			const length = this.length
			for(let i = 0; i < length; i++){
				const a = this[i], score = pred(a, i, this)
				if(score > best){
					best = score
					winner = a
				}
			}
			return winner
		}},
		remove: {enumerable: false, value(a){
			let i = 0, j = 0
			for(; j < this.length; j++){
				if(j > i)this[i] = this[j]
				if(this[i] != a)i++
			}
			this.length = i
			return this
		}},
		mutmap: {enumerable: false, value(fn){
			const len = this.length
			for(let i = 0; i < len; i++)
				this[i] = fn(this[i])
			return this
		}}
	})
	const Can = (w = 100, h = 100) => {
		const c = document.createElement('canvas').getContext('2d')
		c.canvas.width = w; c.canvas.height = h
		//Possible consideration: filling the array with
		c.transforms = []
		return c
	}
	const Blocks = {}, Items = {}, Entities = {}
	const BlockIDs = [], ItemIDs = [], EntityIDs = []
	let Block, Item, Entity, Particle
	let W2 = 0, H2 = 0, SCALE = 1
	const {random, abs, min, max, round, floor, ceil, ifloat, fclamp, sqrt, cbrt, atan2, sign, sin, cos, tan, PI, PI2 = PI * 2, } = Math
	const mac = navigator.platform.startsWith('Mac')
	const LBUTTON = 0, RBUTTON = 2, MBUTTON = 1,
		KEY_A = 65, KEY_B = 66, KEY_C = 67, KEY_D = 68, KEY_E = 69, KEY_F = 70,
		KEY_G = 71, KEY_H = 72, KEY_I = 73, KEY_J = 74, KEY_K = 75, KEY_L = 76,
		KEY_M = 77, KEY_N = 78, KEY_O = 79, KEY_P = 80, KEY_Q = 81, KEY_R = 82,
		KEY_S = 83, KEY_T = 84, KEY_U = 85, KEY_V = 86, KEY_W = 87, KEY_X = 88,
		KEY_Y = 89, KEY_Z = 90, KEY_0 = 48, KEY_1 = 49, KEY_2 = 50, KEY_3 = 51,
		KEY_4 = 52, KEY_5 = 53, KEY_6 = 54, KEY_7 = 55, KEY_8 = 56, KEY_9 = 57,
		KEY_SPACE = 32, KEY_SYMBOL = mac ? 192 : 223, KEY_TAB = 9, KEY_BACK = 8, KEY_SHIFT = 16,
		KEY_CTRL = 17, KEY_ALT = 18, KEY_ESC = 27, KEY_META = 91, KEY_METARIGHT = 93,
		KEY_CAPSLOCK = 20, KEY_UP = 38, KEY_RIGHT = 39, KEY_DOWN = 40, KEY_LEFT = 37, KEY_MOD = mac ? KEY_META : KEY_CTRL,
		KEY_F1 = 112, KEY_F2 = 113, KEY_F3 = 114, KEY_F4 = 115, KEY_F5 = 116, KEY_F6 = 117, KEY_F7 = 118, KEY_F8 = 119, KEY_F9 = 120, KEY_F10 = 121, KEY_F11 = 122, KEY_F12 = 123

	function renderLayer(_1, _2){}
	function uiLayer(_1, _2){}
	function drawPhase(_1, _2){}
	function tickPhase(_1, _2){}
	function button(..._){}
	function onmousemove(_){}
	function onwheel(_){}
	function pause(a){}
	function send(a){}
	function download(a){}
	function onpause(a){}
	function onpacket(c,b){}
	function music(s,t){}
	function sound(s,x,y,v,p){}
	function getblock(x,y){}
	function blockevent(t, r){}
	let loading = 1, loaded = null, dt = 1 / 60
	let buttons, options, paused = false, pointer
	let t = 0, TPS = 20, map = new Map(), entities = new Map()
	let meid = -1, r = 0, me = null
	let ticks = 0, world = '', gx = 0, gy = 0
	let cam = {x: 0, y: 0, z: 2}, mx = 0, my = 0
	let DataReader, DataWriter
	const nul = new Array(1000).fill(null)
	Array.null = len => {
		if(len <= 1000)return nul.slice(0, len)
		let a = new Array(len)
		for(let i = len; i > 0; i--)a[i] = null
		return a
	}
	Function.returns = v => () => v
	const VERSION = 'alpha 6'
</script>
<script type="module">
	import "./bitfield.js"
	import "./chunk.js"
	import "./controls.js"
	import "./entity.js"
	import "./incomingPacket.js"
	import "./ipc.js"
	import "./pointer.js"
	import "./sounds.js"
	import "./world.js"
	import "./index.js"
	import "../data.js"

	const c = Can()
	const { requestAnimationFrame } = globalThis
	void function frame(){

		requestAnimationFrame(frame)
	}()
	
</script>